const HOME = 'home';
const NETWORK_MAP = 'network_map.json';

/** 
 * Create a network map in JSON format
 * @param {NS} ns 
**/
export async function createNetworkMap(ns) {
	const scanHost = (host, myParent, currentData = {}) => {
		const myConnections = ns.scan(host);
		const currentMoney = ns.getServerMoneyAvailable(host);
		const hackTime = ns.getHackTime(host);

		if (host == HOME) {
			myParent = "";
		}

		let newData = {
			...currentData,
			[host]: {
				parent: myParent,
				connections: myConnections,
				root: ns.hasRootAccess(host),
				currentMoney,
				maxMoney: ns.getServerMaxMoney(host),
				hackLevel: ns.getServerRequiredHackingLevel(host),
				hackTime,
				ports: ns.getServerNumPortsRequired(host),
				moneyPerSec: currentMoney / hackTime
			}
		};

		myConnections
			.filter((node) => !newData[node]) // prevent infinite looping...
			.forEach((node) => {
				newData = scanHost(node, host, newData);
			});

		return newData;
	};

	const run = async () => {
		const data = scanHost(HOME, HOME);
		await ns.write(NETWORK_MAP, JSON.stringify(data, null, 2), 'w');
	};
}

/** @param {NS} ns **/
export async function main(ns) {
	const argData = ns.flags([
		['daemon', false]
	]);

	await createNetworkMap(ns);

	if (argData.daemon) {
		while (true) {
			await run();
			await ns.sleep(30000);
		}
	} else {
		await run();
	}
}

/**
* Return an Object of the network map from JSON
* @param {NS} ns
*/
export function readNetworkMap(ns) {
	const NETWORK_MAP = 'network_map.json.txt';
	return JSON.parse(ns.read(NETWORK_MAP));
}

/**
* Search for a specific server by iterating through parents; generally don't call this publicly
* @param {string} server Server to look for
* @param {object} network_map Object of network map as generated by readNetworkMap()
* @param {array} connection_list An array of paths leading up to a server (in reverse order)
* @returns A reverse list of paths leading up a server
*/
function locateServerPrimitive(server, network_map, connection_list) {
	if (network_map[server].parent != '') {
		// ns.tprint(`Current server: ${server}`)
		// ns.tprint(`Parent: ${network_map[server].parent}`)
		connection_list.push(server);
		// ns.tprint(`Current connection list: ${connection_list.join(", ")}`)
		locateServerPrimitive(network_map[server].parent, network_map, connection_list);
	}
	return connection_list;
}

/**
* Search for a path to specific server
* @param {NS} ns
* @param {string} server A server to generate a path for
* @returns Ordered list of servers from home to target server
*/
export async function locateServer(ns, server) {
	// If we don't have a network map yet, make one
	if (!ns.ls('home', 'network_map.json.txt')) {
		await createNetworkMap(ns);
	}
	let network_map = readNetworkMap(ns);
	let premap_to_server = locateServerPrimitive(server, network_map, []);
	premap_to_server.push('home');
	return premap_to_server.reverse();  // this will be a reverse-ordered list from home to target
}